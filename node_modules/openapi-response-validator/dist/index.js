"use strict";
exports.__esModule = true;
var Ajv = require("ajv");
var LOCAL_DEFINITION_REGEX = /^#\/([^\/]+)\/([^\/]+)$/;
var OpenAPIResponseValidator = /** @class */ (function () {
    function OpenAPIResponseValidator(args) {
        var loggingKey = args && args.loggingKey ? args.loggingKey + ': ' : '';
        if (!args) {
            throw new Error(loggingKey + "missing args argument");
        }
        if (!args.responses) {
            throw new Error(loggingKey + "args.responses must be an Object");
        }
        if (!Object.keys(args.responses).length) {
            throw new Error(loggingKey + "args.responses must contain at least 1 response object");
        }
        var errorTransformer = typeof args.errorTransformer === 'function' &&
            args.errorTransformer;
        // @ts-ignore TODO get Ajv updated to account for logger
        var v = new Ajv({ allErrors: true, unknownFormats: 'ignore', missingRefs: 'fail', logger: false });
        this.errorMapper = errorTransformer ?
            makeErrorMapper(errorTransformer) :
            toOpenapiValidationError;
        if (args.customFormats) {
            Object.keys(args.customFormats).forEach(function (format) {
                var func = args.customFormats[format];
                if (typeof func === 'function') {
                    v.addFormat(format, func);
                }
            });
        }
        if (args.externalSchemas) {
            Object.keys(args.externalSchemas).forEach(function (id) {
                v.addSchema(args.externalSchemas[id], id);
            });
        }
        var schemas = getSchemas(args.responses, args.definitions);
        this.validators = compileValidators(v, schemas);
    }
    OpenAPIResponseValidator.prototype.validateResponse = function (statusCode, response) {
        var validator;
        if (statusCode && statusCode in this.validators) {
            validator = this.validators[statusCode];
        }
        else if (this.validators["default"]) {
            validator = this.validators["default"];
        }
        else {
            return {
                message: 'An unknown status code was used and no default was provided.'
            };
        }
        var isValid = validator({
            response: response === undefined ? null : response
        });
        if (!isValid) {
            return {
                message: 'The response was not valid.',
                errors: validator.errors.map(this.errorMapper)
            };
        }
        return undefined;
    };
    return OpenAPIResponseValidator;
}());
exports["default"] = OpenAPIResponseValidator;
function compileValidators(v, schemas) {
    var validators = {};
    Object.keys(schemas).forEach(function (name) {
        validators[name] = v.compile(schemas[name]);
    });
    return validators;
}
function getSchemas(responses, definitions) {
    var schemas = {};
    Object.keys(responses).forEach(function (name) {
        var response = responses[name];
        var schema = response && response.schema && typeof response.schema === 'object' ?
            response.schema :
            { type: "null" };
        schemas[name] = {
            $schema: 'http://json-schema.org/schema#',
            type: 'object',
            properties: {
                response: schema
            },
            definitions: definitions || {}
        };
    });
    return schemas;
}
function makeErrorMapper(mapper) {
    return function (ajvError) { return mapper(toOpenapiValidationError(ajvError), ajvError); };
}
function toOpenapiValidationError(error) {
    var validationError = {
        path: "instance" + error.dataPath,
        errorCode: error.keyword + ".openapi.responseValidation",
        message: error.message
    };
    validationError.path = validationError.path.replace(/^instance\.(?:response\.)?/, '');
    validationError.message = validationError.path + ' ' + validationError.message;
    if (validationError.path === 'response') {
        delete validationError.path;
    }
    return validationError;
}
//# sourceMappingURL=index.js.map