"use strict";
exports.__esModule = true;
var util_1 = require("./src/util");
var fs_routes_1 = require("fs-routes");
var openapi_default_setter_1 = require("openapi-default-setter");
var openapi_schema_validator_1 = require("openapi-schema-validator");
var openapi_request_coercer_1 = require("openapi-request-coercer");
var openapi_request_validator_1 = require("openapi-request-validator");
var openapi_response_validator_1 = require("openapi-response-validator");
var openapi_security_handler_1 = require("openapi-security-handler");
var OpenAPIFramework = /** @class */ (function () {
    function OpenAPIFramework(args) {
        if (args === void 0) { args = {}; }
        var _this = this;
        this.args = args;
        this.name = args.name;
        this.featureType = args.featureType;
        this.loggingPrefix = args.name ?
            this.name + ": " :
            '';
        [
            { name: 'apiDoc', required: true },
            { name: 'errorTransformer', type: 'function' },
            { name: 'externalSchemas', type: 'object' },
            { name: 'featureType', required: true },
            { name: 'name', required: true },
            { name: 'paths', required: true },
            { name: 'pathSecurity', "class": Array, className: 'Array' },
            { name: 'securityHandlers', type: 'object' }
        ].forEach(function (arg) {
            if (arg.required && !(arg.name in args)) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " is required");
            }
            if (arg.type && arg.name in args && typeof args[arg.name] !== arg.type) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " must be a " + arg.type + " when given");
            }
            if (arg["class"] && arg.name in args && !(args[arg.name] instanceof arg["class"])) {
                throw new Error(_this.loggingPrefix + "args." + arg.name + " must be an instance of " + arg.className + " when given");
            }
        });
        this.enableObjectCoercion = !!args.enableObjectCoercion;
        this.originalApiDoc = util_1.handleYaml(util_1.handleFilePath(args.apiDoc));
        this.apiDoc = util_1.copy(this.originalApiDoc);
        this.basePath = (this.apiDoc.basePath || '').replace(/\/$/, '');
        this.validateApiDoc = 'validateApiDoc' in args ?
            !!args.validateApiDoc :
            true;
        this.validator = new openapi_schema_validator_1["default"]({
            version: this.apiDoc.openapi || this.apiDoc.swagger,
            extensions: this.apiDoc["x-" + this.name + "-schema-extension"]
        });
        this.customFormats = args.customFormats;
        this.dependencies = args.dependencies;
        this.errorTransformer = args.errorTransformer;
        this.externalSchemas = args.externalSchemas;
        this.paths = args.paths;
        this.pathsIgnore = args.pathsIgnore;
        this.pathSecurity = Array.isArray(args.pathSecurity) ?
            args.pathSecurity :
            [];
        this.routesGlob = args.routesGlob;
        this.routesIndexFileRegExp = args.routesIndexFileRegExp;
        this.securityHandlers = args.securityHandlers;
        this.pathSecurity.forEach(util_1.assertRegExpAndSecurity.bind(null, this));
        if (this.validateApiDoc) {
            var apiDocValidation = this.validator.validate(this.apiDoc);
            if (apiDocValidation.errors.length) {
                console.error(this.loggingPrefix + "Validating schema before populating paths");
                console.error(this.loggingPrefix + "validation errors", JSON.stringify(apiDocValidation.errors, null, '  '));
                throw new Error(this.loggingPrefix + "args.apiDoc was invalid.  See the output.");
            }
        }
    }
    OpenAPIFramework.prototype.initialize = function (visitor) {
        var _this = this;
        var parameterDefinitions = this.apiDoc.parameters || {};
        var apiSecurityMiddleware = this.securityHandlers &&
            this.apiDoc.security &&
            this.apiDoc.securityDefinitions ?
            new openapi_security_handler_1["default"]({
                securityDefinitions: this.apiDoc.securityDefinitions,
                securityHandlers: this.securityHandlers,
                operationSecurity: this.apiDoc.security,
                loggingKey: this.name + "-security"
            }) :
            null;
        var paths = [].concat(this.paths);
        var routes = [];
        paths.forEach(function (pathItem) {
            if (util_1.byString(pathItem)) {
                pathItem = util_1.toAbsolutePath(pathItem);
                if (!util_1.byDirectory(pathItem)) {
                    throw new Error(_this.loggingPrefix + "args.paths contained a value that was not a path to a directory");
                }
                routes = routes.concat(fs_routes_1["default"](pathItem, {
                    glob: _this.routesGlob,
                    indexFileRegExp: _this.routesIndexFileRegExp
                })
                    .filter(function (fsRoutesItem) {
                    return _this.pathsIgnore ? !_this.pathsIgnore.test(fsRoutesItem.route) : true;
                })
                    .map(function (fsRoutesItem) {
                    return { path: fsRoutesItem.route, module: require(fsRoutesItem.path) };
                }));
            }
            else {
                if (!pathItem.path || !pathItem.module) {
                    throw new Error(_this.loggingPrefix + "args.paths must consist of strings or valid route specifications");
                }
                routes.push(pathItem);
            }
        });
        routes = routes.sort(util_1.byRoute);
        // Check for duplicate routes
        var dups = routes.filter(function (v, i, o) { if (i > 0 && v.path === o[i - 1].path)
            return v.path; });
        if (dups.length > 0) {
            throw new Error(this.loggingPrefix + "args.paths produced duplicate urls for \"" + dups[0].path + "\"");
        }
        var getApiDoc = function () {
            return util_1.copy(_this.apiDoc);
        };
        routes.forEach(function (routeItem) {
            var route = routeItem.path;
            var pathModule = util_1.injectDependencies(routeItem.module["default"] || routeItem.module, _this.dependencies);
            // express path params start with :paramName
            // openapi path params use {paramName}
            var openapiPath = route;
            // Do not make modifications to this.
            var originalPathItem = _this.originalApiDoc.paths[openapiPath] || {};
            var pathDoc = _this.apiDoc.paths[openapiPath] || {};
            var pathParameters = pathDoc.parameters || [];
            // push all parameters defined in the path module to the path parameter list
            if (Array.isArray(pathModule.parameters)) {
                [].push.apply(pathParameters, pathModule.parameters);
            }
            pathDoc.parameters = pathParameters;
            _this.apiDoc.paths[openapiPath] = pathDoc;
            Object.keys(pathModule).filter(util_1.byMethods).forEach(function (methodName) {
                // operationHandler may be an array or a function.
                var operationHandler = pathModule[methodName];
                methodName = util_1.METHOD_ALIASES[methodName];
                var operationDoc = util_1.handleYaml(util_1.getMethodDoc(operationHandler)) || pathDoc[methodName];
                var consumes = operationDoc && Array.isArray(operationDoc.consumes) ?
                    operationDoc.consumes :
                    Array.isArray(_this.apiDoc.consumes) ?
                        _this.apiDoc.consumes :
                        [];
                var operationContext = {
                    additionalFeatures: util_1.getAdditionalFeatures(_this, _this.originalApiDoc, originalPathItem, pathModule, operationDoc),
                    allowsFeatures: util_1.allowsFeatures(_this, _this.apiDoc, pathModule, pathDoc, operationDoc),
                    apiDoc: _this.apiDoc,
                    basePath: _this.basePath,
                    consumes: consumes,
                    features: {},
                    methodName: methodName,
                    methodParameters: [],
                    operationDoc: operationDoc,
                    operationHandler: operationHandler,
                    path: openapiPath
                };
                if (operationDoc) {
                    pathDoc[methodName] = operationDoc;
                    if (operationDoc.tags) {
                        util_1.sortOperationDocTags(operationDoc);
                        operationDoc.tags.forEach(util_1.addOperationTagToApiDoc.bind(null, _this.apiDoc));
                    }
                    if (operationContext.allowsFeatures) {
                        // add features
                        if (operationDoc.responses && util_1.allowsResponseValidationFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                            // add response validation feature
                            // it's invalid for a method doc to not have responses, but the post
                            // validation will pick it up, so this is almost always going to be added.
                            var responseValidator = new openapi_response_validator_1["default"]({
                                loggingKey: _this.name + "-response-validation",
                                definitions: _this.apiDoc.definitions,
                                externalSchemas: _this.externalSchemas,
                                errorTransformer: _this.errorTransformer,
                                responses: util_1.resolveResponseRefs(_this, operationDoc.responses, _this.apiDoc, route),
                                customFormats: _this.customFormats
                            });
                            operationContext.features.responseValidator = responseValidator;
                        }
                        var methodParameters = util_1.withNoDuplicates(util_1.resolveParameterRefs(_this, Array.isArray(operationDoc.parameters) ?
                            pathParameters.concat(operationDoc.parameters) :
                            pathParameters, parameterDefinitions));
                        operationContext.methodParameters = methodParameters;
                        if (methodParameters.length) {
                            // defaults, coercion, and parameter validation middleware
                            if (util_1.allowsValidationFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var requestValidator = new openapi_request_validator_1["default"]({
                                    errorTransformer: _this.errorTransformer,
                                    parameters: methodParameters,
                                    schemas: _this.apiDoc.definitions,
                                    externalSchemas: _this.externalSchemas,
                                    customFormats: _this.customFormats
                                });
                                operationContext.features.requestValidator = requestValidator;
                            }
                            if (util_1.allowsCoercionFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var coercer = new openapi_request_coercer_1["default"]({
                                    extensionBase: "x-" + _this.name + "-coercion",
                                    loggingKey: _this.name + "-coercion",
                                    parameters: methodParameters,
                                    enableObjectCoercion: _this.enableObjectCoercion
                                });
                                operationContext.features.coercer = coercer;
                            }
                            // no point in default feature if we don't have any parameters with defaults.
                            if (methodParameters.filter(util_1.byDefault).length &&
                                util_1.allowsDefaultsFeature(_this, _this.apiDoc, pathModule, pathDoc, operationDoc)) {
                                var defaultSetter = new openapi_default_setter_1["default"]({ parameters: methodParameters });
                                operationContext.features.defaultSetter = defaultSetter;
                            }
                        }
                        var securityFeature = void 0;
                        var securityDefinition = void 0;
                        if (_this.securityHandlers && _this.apiDoc.securityDefinitions) {
                            if (operationDoc.security) {
                                securityDefinition = operationDoc.security;
                            }
                            else if (_this.pathSecurity.length) {
                                securityDefinition = util_1.getSecurityDefinitionByPath(openapiPath, _this.pathSecurity);
                            }
                        }
                        if (securityDefinition) {
                            pathDoc[methodName].security = securityDefinition;
                            securityFeature = new openapi_security_handler_1["default"]({
                                securityDefinitions: _this.apiDoc.securityDefinitions,
                                securityHandlers: _this.securityHandlers,
                                operationSecurity: securityDefinition,
                                loggingKey: _this.name + "-security"
                            });
                        }
                        else if (apiSecurityMiddleware) {
                            securityFeature = apiSecurityMiddleware;
                        }
                        if (securityFeature) {
                            operationContext.features.securityHandler = securityFeature;
                        }
                    }
                }
                if (visitor.visitOperation) {
                    visitor.visitOperation(operationContext);
                }
            });
            if (visitor.visitPath) {
                visitor.visitPath({
                    basePath: _this.basePath,
                    getApiDoc: getApiDoc,
                    getPathDoc: function () { return util_1.copy(pathDoc); }
                });
            }
        });
        util_1.sortApiDocTags(this.apiDoc);
        if (this.validateApiDoc) {
            var apiDocValidation = this.validator.validate(this.apiDoc);
            if (apiDocValidation.errors.length) {
                console.error(this.loggingPrefix + "Validating schema after populating paths");
                console.error(this.loggingPrefix + "validation errors", JSON.stringify(apiDocValidation.errors, null, '  '));
                throw new Error(this.loggingPrefix + "args.apiDoc was invalid after populating paths.  See the output.");
            }
        }
        if (visitor.visitApi) {
            visitor.visitApi({
                basePath: this.basePath,
                getApiDoc: getApiDoc
            });
        }
    };
    return OpenAPIFramework;
}());
exports["default"] = OpenAPIFramework;
//# sourceMappingURL=index.js.map