"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
exports.__esModule = true;
var openapi_framework_1 = require("openapi-framework");
var CASE_SENSITIVE_PARAM_PROPERTY = 'x-express-openapi-case-sensitive';
var normalizeQueryParamsMiddleware = require('express-normalize-query-params-middleware');
var loggingPrefix = 'express-openapi';
function initialize(args) {
    if (!args) {
        throw new Error(loggingPrefix + ": args must be an object");
    }
    if (!args.app) {
        throw new Error(loggingPrefix + ": args.app must be an express app");
    }
    var exposeApiDocs = 'exposeApiDocs' in args ?
        !!args.exposeApiDocs :
        true;
    if (args.docsPath && typeof args.docsPath !== 'string') {
        throw new Error(loggingPrefix + ": args.docsPath must be a string when given");
    }
    if ('securityFilter' in args && typeof args.securityFilter !== 'function') {
        throw new Error(loggingPrefix + ": args.securityFilter must be a function when given");
    }
    var app = args.app;
    var docsPath = args.docsPath || '/api-docs';
    var consumesMiddleware = args.consumesMiddleware;
    var errorMiddleware = typeof args.errorMiddleware === 'function' &&
        args.errorMiddleware.length === 4 ? args.errorMiddleware : null;
    var promiseMode = !!args.promiseMode;
    var securityFilter = args.securityFilter ? (args.promiseMode ?
        toPromiseCompatibleMiddleware(args.securityFilter) :
        args.securityFilter) : function defaultSecurityFilter(req, res, next) {
        res.status(200).json(req.apiDoc);
    };
    var frameworkArgs = __assign({ featureType: 'middleware', name: loggingPrefix }, args);
    var framework = new openapi_framework_1["default"](frameworkArgs);
    framework.initialize({
        visitApi: function (ctx) {
            if (exposeApiDocs) {
                // Swagger UI support
                app.get(ctx.basePath + docsPath, function (req, res, next) {
                    // @ts-ignore
                    req.apiDoc = ctx.getApiDoc();
                    // @ts-ignore
                    if (req.apiDoc.swagger) {
                        // @ts-ignore
                        req.apiDoc.host = req.headers.host;
                        // @ts-ignore
                        req.apiDoc.basePath = req.baseUrl + ctx.basePath;
                    }
                    securityFilter(req, res, next);
                });
            }
            if (errorMiddleware) {
                app.use(ctx.basePath, errorMiddleware);
            }
        },
        visitOperation: function (ctx) {
            var apiDoc = ctx.apiDoc;
            var methodName = ctx.methodName;
            var operationDoc = ctx.operationDoc;
            var operationHandler = ctx.operationHandler;
            var middleware = [].concat(ctx.additionalFeatures);
            if (operationDoc && ctx.allowsFeatures) {
                middleware.unshift(createAssignApiDocMiddleware(apiDoc, operationDoc));
                if (ctx.features.responseValidator) {
                    // add response validation middleware
                    // it's invalid for a method doc to not have responses, but the post
                    // validation will pick it up, so this is almost always going to be added.
                    middleware.unshift(function responseValidatorMiddleware(req, res, next) {
                        res.validateResponse = function (statusCode, response) {
                            return ctx.features.responseValidator.validateResponse(statusCode, response);
                        };
                        next();
                    });
                }
                if (ctx.features.requestValidator) {
                    middleware.unshift(function requestValidatorMiddleware(req, res, next) {
                        next(ctx.features.requestValidator.validate(req));
                    });
                }
                if (ctx.features.coercer) {
                    middleware.unshift(function coercerMiddleware(req, res, next) {
                        ctx.features.coercer.coerce(req);
                        next();
                    });
                }
                if (ctx.features.defaultSetter) {
                    middleware.unshift(function defaultMiddleware(req, res, next) {
                        ctx.features.defaultSetter.handle(req);
                        next();
                    });
                }
                if (ctx.features.securityHandler) {
                    middleware.push(function (req, res, next) {
                        ctx.features.securityHandler.handle(req).then(next)["catch"](next);
                    });
                }
                if (consumesMiddleware && ctx.consumes) {
                    addConsumesMiddleware(middleware, consumesMiddleware, ctx.consumes);
                }
            }
            middleware.push(operationHandler);
            optionallyAddQueryNormalizationMiddleware(middleware, ctx.methodParameters);
            if (promiseMode) {
                middleware = [].concat.apply([], middleware).map(toPromiseCompatibleMiddleware);
            }
            var expressPath = ctx.basePath + '/' +
                ctx.path.substring(1).split('/').map(toExpressParams).join('/');
            app[methodName].apply(app, [expressPath].concat(middleware));
        }
    });
    return framework;
}
exports.initialize = initialize;
function addConsumesMiddleware(middleware, consumesMiddleware, consumes) {
    for (var i = consumes.length - 1; i >= 0; --i) {
        var mimeType = consumes[i];
        if (mimeType in consumesMiddleware) {
            var middlewareToAdd = consumesMiddleware[mimeType];
            middleware.unshift(middlewareToAdd);
        }
    }
}
function createAssignApiDocMiddleware(apiDoc, operationDoc) {
    return function assignApiDocMiddleware(req, res, next) {
        req.apiDoc = apiDoc;
        req.operationDoc = operationDoc;
        next();
    };
}
function optionallyAddQueryNormalizationMiddleware(middleware, methodParameters) {
    if (!methodParameters) {
        return;
    }
    var queryParamsNeedingNormalization = methodParameters.filter(function (param) {
        return param["in"] === 'query' && param[CASE_SENSITIVE_PARAM_PROPERTY] === false;
    }).map(function (param) {
        return param.name;
    });
    if (queryParamsNeedingNormalization.length) {
        middleware.unshift(normalizeQueryParamsMiddleware(queryParamsNeedingNormalization));
    }
}
function toExpressParams(part) {
    return part.replace(/\{([^}]+)}/g, ':$1');
}
function toPromiseCompatibleMiddleware(fn) {
    if (typeof fn === 'function' && fn.name !== 'expressOpenapiPromiseMiddleware') {
        return function expressOpenapiPromiseMiddleware(req, res, next) {
            var potentialPromise = fn(req, res, next);
            if (potentialPromise && typeof potentialPromise["catch"] === 'function') {
                potentialPromise["catch"](next);
            }
        };
    }
    return fn;
}
//# sourceMappingURL=index.js.map